bool propagateGivesConflict (vector<int> litsToPropagate) {
    bool fallo = false;
    int pSize = litsToPropagate.size();
    for(uint j = 0; j < pSize and not fallo; ++j) {
        vector<int> vAux;
        if (litsToPropagate[j] > 0) vAux = clausNeg[litsToPropagate[j]];
        else vAux = clausPos[abs(litsToPropagate[j])];
        int vSize = vAux.size();
        for (uint i = 0; i < vSize; ++i) {
            bool someLitTrue = false;
            int numUndefs = 0;
            int lastLitUndef = 0;
            for (uint k = 0; not someLitTrue and k < clauses[vAux[i]].size(); ++k){
                int val = currentValueInModel(clauses[vAux[i]][k]);
                if (val == TRUE) someLitTrue = true;
                else if (val == UNDEF){ ++numUndefs; lastLitUndef = clauses[vAux[i]][k]; }
            }
            if (not someLitTrue and numUndefs == 0) {
                fallo = true; // conflict! all lits false
                if (litsToPropagate[j] > 0) ++conflictivePos[litsToPropagate[j]];
                else ++conflictiveNeg[-litsToPropagate[j]];
            }
            else if (not someLitTrue and numUndefs == 1 and not fallo) {
                setLiteralToTrue(lastLitUndef);
                litsToPropagate.push_back(lastLitUndef);
                ++pSize;
            }
        }
    }
    return fallo;
}

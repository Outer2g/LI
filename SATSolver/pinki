bool propagateGivesConflict (vector<int> litsToPropagate) {
    bool fallo = false;
    int pSize=litsToPropagate.size();
    for (int j=0;not fallo and j<pSize;++j){
        vector<int> vAux;
        if (litsToPropagate[j]>0) vAux = clausNeg[litsToPropagate[j]];
        else vAux = clausPos[litsToPropagate[j]];
        int vSize = vAux.size();
        for (int i=0;i<vSize;++i){
            bool someLitTrue = false;
            int numUndefs = 0;
            int lastLitUndef = 0;
            for (int k=0;not someLitTrue and k<clauses[vAux[i]].size();++k){
                int val = currentValueInModel(clauses[vAux[i]][k]);//kfkf
                if (val == TRUE) someLitTrue = true;
                else if (val == UNDEF){ ++numUndefs; lastLitUndef = clauses[vAux[i]][k];}
            }
            if (not someLitTrue and numUndefs == 0){
                fallo=true; // fallo! all lits false
                if (litsToPropagate[j]>0) ++conflictivePos[litsToPropagate[j]];
                else ++conflictiveNeg[-litsToPropagate[j]];
            }
            else if (not someLitTrue and numUndefs == 1 and not fallo){
                setLiteralToTrue(lastLitUndef);
                litsToPropagate.push_back(lastLitUndef);
                ++pSize;
            }
        }
    }
    return fallo;
}